<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>chemgraphbuilder.relationship_properties_extractor API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>chemgraphbuilder.relationship_properties_extractor</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor"><code class="flex name class">
<span>class <span class="ident">RelationshipPropertiesExtractor</span></span>
</code></dt>
<dd>
<div class="desc"><p>Extracts and analyzes relationship properties among compounds, genes, and assays from the PubChem database.</p>
<p>This class facilitates the retrieval of complex relational data between chemical entities, enabling detailed
analysis of biochemical interactions and properties. The extracted data is ideal for constructing knowledge
graphs, supporting drug discovery, and understanding genetic influences on compound behavior.</p>
<p>Methods within the class are tailored to query specific relationship types from PubChem, including
compound-assay relationships, compound co-occurrences, and compound transformations influenced by genes.
Data fetched from PubChem is processed and saved in structured formats (CSV files), ready for further analysis
or database integration.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code>requests.Session</code></dt>
<dd>Session object to persist certain parameters across requests.</dd>
</dl>
<h2 id="usage">Usage</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
&gt;&gt;&gt; extractor.assay_compound_relationship(&quot;Data/AllDataCollected.csv&quot;)
This example fetches assay-compound relationship data for specified assays and saves the data to CSV files.
</code></pre>
<p>Initializes a RelationshipPropertiesExtractor with a Requests session for efficient network calls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationshipPropertiesExtractor:
    &#34;&#34;&#34;
    Extracts and analyzes relationship properties among compounds, genes, and assays from the PubChem database.

    This class facilitates the retrieval of complex relational data between chemical entities, enabling detailed
    analysis of biochemical interactions and properties. The extracted data is ideal for constructing knowledge
    graphs, supporting drug discovery, and understanding genetic influences on compound behavior.

    Methods within the class are tailored to query specific relationship types from PubChem, including
    compound-assay relationships, compound co-occurrences, and compound transformations influenced by genes.
    Data fetched from PubChem is processed and saved in structured formats (CSV files), ready for further analysis
    or database integration.

    Attributes:
        session (requests.Session): Session object to persist certain parameters across requests.

    Usage:
        &gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
        &gt;&gt;&gt; extractor.assay_compound_relationship(&#34;Data/AllDataCollected.csv&#34;)
        This example fetches assay-compound relationship data for specified assays and saves the data to CSV files.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initializes a RelationshipPropertiesExtractor with a Requests session for efficient network calls.&#34;&#34;&#34;
        self.session = requests.Session()


    def create_data_directories(self):
        &#34;&#34;&#34;
        Creates the necessary directories for storing fetched and processed data if they do not already exist.

        This method checks for the existence of several predefined directories where data will be saved during the execution
        of other methods within this class. If any of these directories do not exist, they are created. This setup ensures
        that data saving operations do not encounter errors due to missing directories.

        The directories created include:
        - &#39;Data/Relationships/Assay_Compound_Relationship&#39;: For storing relationships between assays and compounds.
        - &#39;Data/Relationships/Cpd_Cpd_CoOcuurence&#39;: For storing compound-compound co-occurrence data.
        - &#39;Data/Relationships/Cpd_gene_CoOcuurence&#39;: For storing compound-gene co-occurrence data.
        - &#39;Data/Relationships/Compound_Transformation&#39;: For storing compound transformation data.

        Side Effects:
            Creates directories on the filesystem if they do not exist.

        Example:
            &gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
            &gt;&gt;&gt; extractor.create_data_directories()
            This example ensures that the required directories for data storage are available before fetching and processing data.

        Note:
            This method should be called before executing data fetching and processing methods to ensure the required directories are available.
            It is designed to prevent FileNotFoundError when methods attempt to save data to these directories.
        &#34;&#34;&#34;
        directories = [
            &#39;Data/Relationships&#39;,
            &#39;Data/Relationships/Assay_Compound_Relationship&#39;,
            &#39;Data/Relationships/Cpd_Cpd_CoOcuurence&#39;,
            &#39;Data/Relationships/Cpd_gene_CoOcuurence&#39;,
            &#39;Data/Relationships/Compound_Similarities&#39;
        ]

        # Iterate through the directories list and create each one if it doesn&#39;t exist
        for directory in directories:
            if not os.path.exists(directory):
                os.makedirs(directory)
                print(f&#34;Created directory: {directory}&#34;)
            else:
                print(f&#34;Directory already exists: {directory}&#34;)


    def _send_request(self, url, max_retries=5, initial_wait=1):
        for attempt in range(max_retries):
            try:
                response = self.session.get(url, timeout=30)
                response.raise_for_status()
                return response
            except requests.HTTPError as e:
                if response.status_code == 503:
                    wait = initial_wait * (2 ** attempt)
                    print(f&#34;Server busy or under maintenance. Retrying in {wait} seconds...&#34;)
                    time.sleep(wait)
                else:
                    print(f&#34;HTTP Error: {e}&#34;)
                    break  # Break the loop for non-503 HTTP errors
            except requests.RequestException as e:
                print(f&#34;Request Exception: {e}&#34;)
                wait = initial_wait * (2 ** attempt)
                print(f&#34;Network error. Retrying in {wait} seconds...&#34;)
                time.sleep(wait)
        return None  # Return None to indicate failure after all retries


    def fetch_data_for_aid(self, aid, columns_to_remove):
        &#34;&#34;&#34;
        Fetches and processes assay data for a specified Assay ID (AID) from the PubChem database, preparing it for analysis or further processing.

        This method queries the PubChem database for assay data associated with a given AID. It constructs the query URL,
        sends the request using a previously established session, and processes the response. The response is expected to be in CSV format,
        which this method reads into a pandas DataFrame. Specific columns can be removed from this DataFrame based on the requirements
        for analysis. This allows for the customization of the fetched data, making it easier to work with specific datasets.

        If the request is successful and the data is fetched without issues, it undergoes initial processing to remove unwanted columns
        as specified by the &#39;columns_to_remove&#39; parameter. In case of an error during the data fetching or processing (e.g., issues with parsing the CSV data),
        appropriate error messages are logged, and an empty DataFrame is returned as a fallback.

        Parameters:
            aid (int): The assay ID for which data is to be fetched. This ID is used to construct the query URL to the PubChem database.
            columns_to_remove (list of str): A list of column names that should be removed from the fetched DataFrame. This allows for the exclusion
                                            of data that might not be relevant to the subsequent analysis or processing steps.

        Returns:
            pandas.DataFrame: A DataFrame containing the processed data associated with the given AID. The DataFrame will exclude columns listed
                            in &#39;columns_to_remove&#39;. If the data fetching fails or if an error occurs during processing, an empty DataFrame is returned.

        Raises:
            requests.RequestException: If an error occurs during the HTTP request to the PubChem API. This includes scenarios such as timeout issues,
                                    non-200 status codes, or network-related errors. The exception is handled internally with logging, but it&#39;s
                                    important to be aware of its possibility.
            pd.errors.ParserError: If an error occurs while parsing the CSV response from PubChem into a DataFrame. This could happen due to malformed
                                data or unexpected changes in the response format. Like with RequestException, this error is logged and results in
                                the return of an empty DataFrame.

        Example:
            &gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
            &gt;&gt;&gt; processed_data_df = extractor.fetch_data_for_aid(12345, [&#39;UnwantedColumn1&#39;, &#39;UnwantedColumn2&#39;])
            &gt;&gt;&gt; print(processed_data_df.head())
            This example demonstrates how to fetch and process assay data for the assay with ID 12345, removing &#39;UnwantedColumn1&#39; and &#39;UnwantedColumn2&#39;
            from the resulting DataFrame. The first few rows of the processed DataFrame are printed as an output.

        Note:
            - This method is part of a class that requires a valid session with the PubChem API. Ensure that the class is properly initialized and that
            the session is active.
            - The removal of columns is an optional step and can be customized based on the analysis needs. If no columns need to be removed, pass an
            empty list as &#39;columns_to_remove&#39;.
        &#34;&#34;&#34;
        url = f&#34;https://pubchem.ncbi.nlm.nih.gov/assay/pcget.cgi?query=download&amp;record_type=datatable&amp;actvty=all&amp;response_type=display&amp;aid={aid}&#34;
        response = self._send_request(url)
        if response and response.status_code == 200:
            try:
                compound_df = pd.read_csv(StringIO(response.text), sep=&#39;,&#39;)
                # Drop specified columns and process column names in-place for memory efficiency
                columns_to_remove_set = set(columns_to_remove)
                existing_columns_set = set(compound_df.columns)
                columns_to_actually_remove = list(columns_to_remove_set &amp; existing_columns_set)
                compound_df.drop(columns=columns_to_actually_remove, errors=&#39;ignore&#39;, inplace=True)
                compound_df.rename(columns=lambda x: x.replace(&#39;PUBCHEM_&#39;, &#39;&#39;) if x.startswith(&#39;PUBCHEM_&#39;) else x, inplace=True)

                # compound_df.drop(columns=[col for col in columns_to_remove if col in compound_df.columns], errors=&#39;ignore&#39;, inplace=True)
                # compound_df.columns = [col.replace(&#39;PUBCHEM_&#39;, &#39;&#39;) if col.startswith(&#39;PUBCHEM_&#39;) else col for col in compound_df.columns]
                compound_df[&#39;AID&#39;] = aid
                return compound_df
            except pd.errors.ParserError as e:
                logging.error(f&#34;CSV parsing failed for AID {aid}: {e}&#34;)
        else:
            logging.error(f&#34;Failed to fetch data for AID {aid}. Status code: {response.status_code if response else &#39;No Response&#39;}&#34;)
        return pd.DataFrame()  # Return an empty DataFrame in case of failure



    def _process_dataframe(self, df, aid, columns_to_remove):
        &#34;&#34;&#34;
        Processes the DataFrame by removing specified columns and renaming others.

        Parameters:
            df (pandas.DataFrame): The DataFrame to be processed.
            aid (int): The assay ID associated with the DataFrame.
            columns_to_remove (list of str): Columns to be removed from the DataFrame.
        &#34;&#34;&#34;
        # Drop unnecessary columns efficiently
        columns_to_remove_set = set(columns_to_remove)
        df = df.drop(columns=list(columns_to_remove_set.intersection(df.columns)), errors=&#39;ignore&#39;)

        # Efficiently rename columns that start with &#39;PUBCHEM_&#39;
        df.columns = [col.replace(&#39;PUBCHEM_&#39;, &#39;&#39;) if col.startswith(&#39;PUBCHEM_&#39;) else col for col in df.columns]
        df[&#39;AID&#39;] = aid


    def assay_compound_relationship(self, assays_data, chunk_size=100):
        &#34;&#34;&#34;
        Processes and stores relationships between assays and compounds based on assay data from PubChem.

        The method utilizes chunk processing and limited concurrent requests to minimize memory usage.

        Args:
            assays_data (str): Path to a CSV file containing assay IDs (AIDs).
            chunk_size (int): Number of rows per chunk to process from the assays_data file.
            max_workers (int): Maximum number of concurrent threads for data fetching.
        &#34;&#34;&#34;

        for chunk in pd.read_csv(assays_data, chunksize=chunk_size):
            columns_to_remove = [&#39;PUBCHEM_RESULT_TAG&#39;, &#39;PUBCHEM_SID&#39;, &#39;PUBCHEM_EXT_DATASOURCE_SMILES&#39;]
            output_dir = &#39;Data/Relationships/Assay_Compound_Relationship&#39;

            # Process each assay ID in the chunk
            for aid in chunk[&#39;AID&#39;]:
                if not os.path.exists(f&#39;{output_dir}/AID_{aid}.csv&#39;):
                    df = self.fetch_data_for_aid(aid, columns_to_remove)
                    if not df.empty:
                        if not os.path.exists(output_dir):
                            os.makedirs(output_dir)
                        df.to_csv(f&#39;{output_dir}/AID_{aid}.csv&#39;, index=False)



    def _write_to_csv(self, df, filename):
        &#34;&#34;&#34;
        Writes a DataFrame to a CSV file.
        &#34;&#34;&#34;
        df.to_csv(filename, index=False)


    def assay_enzyme_relationship(self, main_data):
        &#34;&#34;&#34;
        Extracts and saves relationships between assays and enzymes from the specified dataset.

        This method processes assay data to identify relationships between assays and their target enzymes. It selects
        relevant columns from the input data, removes duplicates to ensure unique relationships, and saves the cleaned data
        to a CSV file for further analysis or integration into knowledge graphs.

        Parameters:
            main_data (str): Path to the CSV file containing the main data. The file should include columns for &#39;AID&#39;
                            (Assay ID), &#39;Target GeneID&#39;, and &#39;Activity Name&#39;.

        Returns:
            pandas.DataFrame: A DataFrame containing the unique relationships between assays and enzymes, including the assay
                            ID, target gene ID, and activity name.

        Side Effects:
            - Writes a CSV file to &#39;Data/Assay_Enzyme_Relationship.csv&#39;, containing the processed relationships data.
        &#34;&#34;&#34;
        df = pd.read_csv(main_data)
        columns_to_select = [&#39;AID&#39;, &#39;Target GeneID&#39;, &#39;Activity Name&#39;]
        df = df[columns_to_select]
        df = df.drop_duplicates(keep=&#39;first&#39;, ignore_index=True)
        df.to_csv(f&#39;Data/Assay_Enzyme_Relationship.csv&#39;, index=False)
        return df


    def gene_enzyme_relationship(self, main_data):
        &#34;&#34;&#34;
        Extracts and saves relationships between genes and enzymes based on the provided dataset.

        This method selects relevant columns to highlight the relationships between genes and their corresponding enzymes.
        It removes duplicate entries to ensure that each relationship is represented uniquely and saves the resultant data to
        a CSV file. This facilitates easy integration of genetic data into knowledge bases or further analysis.

        Parameters:
            main_data (str): Path to the CSV file containing gene and enzyme data. Expected columns include &#39;Target GeneID&#39;
                            and &#39;Target Accession&#39;.

        Returns:
            pandas.DataFrame: A DataFrame of unique gene-enzyme relationships, including gene ID and enzyme accession numbers.

        Side Effects:
            - Writes the processed data to &#39;Data/Gene_Enzyme_Relationship.csv&#39; in a structured CSV format.
        &#34;&#34;&#34;
        df = pd.read_csv(main_data)
        columns_to_select = [&#39;Target GeneID&#39;, &#39;Target Accession&#39;]
        df = df[columns_to_select]
        df = df.drop_duplicates(keep=&#39;first&#39;, ignore_index=True)
        df.to_csv(f&#39;Data/Gene_Enzyme_Relationship.csv&#39;, index=False)
        return df


    def compound_enzyme_relationship(self, main_data):
        &#34;&#34;&#34;
        Identifies and records relationships between compounds and enzymes from the input data.

        This method focuses on extracting compound-enzyme interaction data, including activity outcomes and values. It selects
        pertinent columns, removes duplicate records, and sorts the data by Compound ID and Target Accession for clarity. The
        cleaned dataset is then saved to a CSV file, providing a structured view of how compounds interact with various enzymes,
        which can be critical for drug discovery and pharmacological research.

        Parameters:
            main_data (str): Path to the CSV file with compound and enzyme data. This file should contain columns for &#39;CID&#39;
                            (Compound ID), &#39;Target Accession&#39;, &#39;Activity Outcome&#39;, &#39;Activity Name&#39;, and &#39;Activity Value [uM]&#39;.

        Returns:
            pandas.DataFrame: A DataFrame with processed compound-enzyme relationships, sorted and cleaned for direct analysis or database insertion.

        Side Effects:
            - Saves the processed relationships data to &#39;Data/Relationships/Compound_Enzyme_Relationship.csv&#39;, facilitating easy access and integration.
        &#34;&#34;&#34;
        df = pd.read_csv(main_data)
        columns_to_select = [&#39;CID&#39;, &#39;Target Accession&#39;, &#39;Activity Outcome&#39;,
                             &#39;Activity Name&#39;, &#39;Activity Value [uM]&#39;]
        df = df[columns_to_select]
        df = df.drop_duplicates(keep=&#39;first&#39;, ignore_index=True)
        df = df.sort_values([&#39;CID&#39;, &#39;Target Accession&#39;])
        df.dropna(axis=0 , thresh=1, inplace=True) ###
        df.to_csv(f&#39;Data/Relationships/Compound_Enzyme_Relationship.csv&#39;, index=False)
        return df


    def fetch_similar_cids(self, cid):
        &#34;&#34;&#34;
        Fetches similar compound IDs (CIDs) from the PubChem database for a given compound ID (CID) using 2D similarity.

        This method queries the PubChem database to find compounds that are similar to the given CID based on 2D structural
        similarity. The similarity threshold is set to 95%, and a maximum of 100 similar CIDs are fetched. The response is
        parsed from XML format to extract the similar CIDs.

        Parameters:
            cid (int): The compound ID for which similar CIDs are to be fetched.

        Returns:
            tuple: A tuple containing the original CID and a list of similar CIDs. If an error occurs, the list of similar
            CIDs will be empty.

        Raises:
            Exception: Logs an error message with the original CID and the exception if the request to PubChem fails or
            if parsing the XML response encounters an error.

        Note:
            - The method utilizes the `requests` library for HTTP requests and `xml.etree.ElementTree` for XML parsing.
            - In case of a request failure or parsing error, the method logs the error and returns the original CID with an
            empty list, allowing the calling function to handle the exception as needed.
        &#34;&#34;&#34;
        url = (&#34;https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/&#34;
               f&#34;fastsimilarity_2d/cid/{int(cid)}/cids/XML?Threshold=95&amp;MaxRecords=100&#34;)
        try:
            response = requests.get(url)
            response.raise_for_status()
            xml_data = response.text

            # Parse XML data
            tree = ET.parse(io.StringIO(xml_data))
            root = tree.getroot()

            # Extracting CID values
            similar_cids = [element.text for element in root.findall(&#39;{http://pubchem.ncbi.nlm.nih.gov/pug_rest}CID&#39;)]
            return cid, similar_cids
        except Exception as e:
            logging.error(f&#34;Error processing CID {cid}: {e}&#34;)
            return cid, []


    def process_chunk(self, chunk):
        &#34;&#34;&#34;
        Processes a chunk of CIDs in parallel to fetch similar CIDs for each CID in the chunk.

        This method uses a ThreadPoolExecutor to send out concurrent requests for fetching similar CIDs for a list of CIDs.
        The number of worker threads is set to 5. Each CID&#39;s request is handled by `fetch_similar_cids` method.

        Parameters:
            chunk (list of int): A list of compound IDs (CIDs) to process in parallel.

        Returns:
            list of tuples: A list of tuples, each containing a CID and its corresponding list of similar CIDs.

        Side Effects:
            - Utilizes concurrent threads to speed up the fetching process.
            - May log errors if any occur during the fetching of similar CIDs for individual CIDs.
        &#34;&#34;&#34;
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(self.fetch_similar_cids, cid) for cid in chunk]
            results = [future.result() for future in as_completed(futures)]
        return results


    def compound_similarity_relationship(self, main_data):
        &#34;&#34;&#34;
        Identifies and records the similarity relationships between compounds based on a list of CIDs.

        This method reads a CSV file containing compound data, filters compounds based on specific &#39;Target GeneID&#39; values,
        and fetches similar CIDs for each compound. The compounds are processed in chunks to manage memory usage and improve
        efficiency. The results are saved into separate CSV files for each chunk.

        Parameters:
            main_data (str): Path to the CSV file containing the main compound data. This file should include at least &#39;CID&#39;
                            and &#39;Target GeneID&#39; columns.

        Side Effects:
            - Reads from a CSV file specified by `main_data`.
            - Processes compounds in chunks to efficiently handle large datasets.
            - Saves the results of similar CIDs for each chunk to separate CSV files within &#39;Data/Relationships/Compound_Similarities&#39; directory.
            - Logs information about processing and potential errors during the similarity fetching process.

        Note:
            - The method filters the main data for compounds associated with specific &#39;Target GeneID&#39; values before fetching
              similar CIDs, optimizing the process for relevant compounds only.
            - The division of CIDs into chunks and concurrent processing helps in managing large datasets and utilizes
              parallelism for faster execution.
        &#34;&#34;&#34;
        # Read main data and filter
        df = pd.read_csv(main_data)
        df = df[df[&#39;Target GeneID&#39;].isin([1576, 1544, 1557, 1559, 1565])]
        df = df.dropna(subset=[&#39;CID&#39;])
        IDs = df[&#39;CID&#39;].unique().tolist()

        # Divide the IDs into chunks of 10000
        chunk_size = 10000
        chunks = [IDs[i:i + chunk_size] for i in range(0, len(IDs), chunk_size)]

        for i, chunk in enumerate(chunks, start=0): #chuncks rannge, numbering start for naming
            chunk_results = self.process_chunk(chunk)
            chunk_df = pd.DataFrame(chunk_results, columns=[&#39;CID&#39;, &#39;Similar CIDs&#39;])
            chunk_df.to_csv(f&#39;Data/Relationships/Compound_Similarities/Chunk_{i}.csv&#39;, index=False)


    def _fetch_data(self, cid):
        &#34;&#34;&#34;
        Fetches chemical-chemical and chemical-gene relationship data for a given compound ID (CID).
        Checks if each data file exists before fetching.

        Args:
            cid (int): The compound ID for which data is to be fetched.

        Returns:
            tuple: A tuple containing the CID, and two lists of data (chemical-chemical and chemical-gene relationships).
        &#34;&#34;&#34;
        cpd_cpd_file = f&#39;Data/Relationships/Cpd_Cpd_CoOcuurence/CID_{cid}.csv&#39;
        cpd_gene_file = f&#39;Data/Relationships/Cpd_gene_CoOcuurence/CID_{cid}.csv&#39;

        cpd_cpd_data = self._fetch_chemical_neighbor_data(cid) if not os.path.exists(cpd_cpd_file) else []
        cpd_gene_data = self._fetch_chemical_gene_data(cid) if not os.path.exists(cpd_gene_file) else []

        return cid, cpd_cpd_data, cpd_gene_data


    def _fetch_chemical_neighbor_data(self, cid):
        &#34;&#34;&#34;
        Fetches chemical-chemical relationship data for a given CID.

        Args:
            cid (int): The compound ID for which data is to be fetched.

        Returns:
            list: List of chemical-chemical relationship data.
        &#34;&#34;&#34;
        cpd_cpd_url = (f&#34;https://pubchem.ncbi.nlm.nih.gov/link_db/link_db_server.cgi?format=JSON&amp;type=&#34;
                       f&#34;ChemicalNeighbor&amp;operation=GetAllLinks&amp;id_1={cid}&amp;response_type=display&#34;)
        try:
            response = self._send_request(cpd_cpd_url)
            data = response.json()
            return data.get(&#39;LinkDataSet&#39;, {}).get(&#39;LinkData&#39;, [])
        except Exception as e:
            logging.error(f&#34;Failed to fetch chemical-chemical data for CID {cid}: {e}&#34;)
            return []


    def _fetch_chemical_gene_data(self, cid):
        &#34;&#34;&#34;
        Fetches chemical-gene relationship data for a given CID.

        Args:
            cid (int): The compound ID for which data is to be fetched.

        Returns:
            list: List of chemical-gene relationship data.
        &#34;&#34;&#34;
        cpd_gene_url = (f&#34;https://pubchem.ncbi.nlm.nih.gov/link_db/link_db_server.cgi?format=JSON&amp;type=&#34;
                        f&#34;ChemicalGeneSymbolNeighbor&amp;operation=GetAllLinks&amp;id_1={cid}&amp;response_type=display&#34;)
        try:
            response = self._send_request(cpd_gene_url)
            data = response.json()
            return data.get(&#39;LinkDataSet&#39;, {}).get(&#39;LinkData&#39;, [])
        except Exception as e:
            logging.error(f&#34;Failed to fetch chemical-gene data for CID {cid}: {e}&#34;)
            return []


    def _write_data_to_csv(self, data, filename, filter_condition=None):
        &#34;&#34;&#34;
        Writes given data to a CSV file, with optional filtering before saving.

        This method takes a list of dictionaries (data), converts it into a pandas DataFrame, and optionally filters the DataFrame based on
        specified conditions before writing the result to a CSV file. The filtering is performed on specified columns with their expected
        values provided in &#39;filter_condition&#39;. This allows for selective data saving, especially useful when dealing with large datasets
        or when only a subset of data is needed for further processing or analysis.

        Parameters:
            data (list of dict): Data to be written to a CSV file. Each dictionary in the list represents a row in the DataFrame,
                                with keys as column names and values as row values.
            filename (str): Path to the CSV file where the data will be saved. If the file exists, it will be overwritten.
            filter_condition (dict, optional): A dictionary specifying the columns to filter by and the values to include. Keys in the
                                                dictionary are column names, and values are lists of acceptable values for that column.
                                                Rows not meeting the filter condition are excluded from the final DataFrame to be saved.

        Side Effects:
            - Writes a CSV file to the given filename path. The file is overwritten if it already exists.
            - Logs a warning if a specified column for filtering is not found in the DataFrame.
        &#34;&#34;&#34;

        df = pd.DataFrame(data)
        if filter_condition:
            for column, values in filter_condition.items():
                if column in df.columns:
                    df = df[df[column].isin(values)]
                else:
                    logging.warning(f&#34;Column {column} not found in DataFrame.&#34;)
        if not df.empty:
            df.to_csv(filename, index=False)


    def compound_cooccurrence(self, main_data, rate_limit=5):
        &#34;&#34;&#34;
        Analyzes compound co-occurrence relationships from the specified main data file and saves the results into structured CSV files.

        This method takes a path to a CSV file containing compound data and performs batch processing to extract relationships
        between compounds and genes from the PubChem database. It filters compounds based on their association with specific genes
        of interest, then fetches co-occurrence data for each compound using parallel requests. The data fetched includes both
        compound-compound and compound-gene co-occurrence relationships. Results are saved in separate CSV files within specific
        directories for later analysis.

        Parameters:
            main_data (str): Path to the CSV file containing the main data. This file should include &#39;CID&#39; (Compound ID) and
                            &#39;Target GeneID&#39; columns.
            rate_limit (int): Controls the rate of API requests to avoid exceeding PubChem&#39;s request limits. Specifies the maximum
                            number of requests that can be made per second.

        Side Effects:
            - Creates CSV files in &#39;Data/Relationships/Cpd_Cpd_CoOcuurence&#39; and &#39;Data/Relationships/Cpd_gene_CoOcuurence&#39;
            directories, storing compound-compound and compound-gene co-occurrence data, respectively.
            - Logs the processing time for each chunk of data and any errors encountered during data fetching.

        Returns:
            str: A message indicating the successful completion of data processing and saving.

        Raises:
            FileNotFoundError: If the specified &#39;main_data&#39; file does not exist or cannot be read.
            ValueError: If &#39;main_data&#39; does not contain the required columns (&#39;CID&#39; and &#39;Target GeneID&#39;).

        Example:
            &gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
            &gt;&gt;&gt; completion_message = extractor.compound_cooccurrence(&#39;Data/AllDataConnected.csv&#39;, rate_limit=5)
            &gt;&gt;&gt; print(completion_message)
            This would process the compound data, fetch co-occurrence data from PubChem, and save the results into CSV files.
            The completion message would indicate successful processing.

        Note:
            The &#39;main_data&#39; file must be properly formatted, with at least &#39;CID&#39; and &#39;Target GeneID&#39; columns present. The method
            assumes the existence of &#39;Data/Relationships/Cpd_Cpd_CoOcuurence&#39; and &#39;Data/Relationships/Cpd_gene_CoOcuurence&#39;
            directories for saving the output CSV files. It is recommended to check and adhere to PubChem&#39;s current rate limits
            when setting the &#39;rate_limit&#39; parameter to avoid potential blocks or restrictions on your IP address due to excessive requests.
        &#34;&#34;&#34;
        df = pd.read_csv(main_data, chunksize=3000)  # Reading in chunks for large files
        for chunk in df:
            chunk = chunk[chunk[&#39;Target GeneID&#39;].isin([1576, 1544, 1557, 1559, 1565])]
            chunk.dropna(subset=[&#39;CID&#39;], inplace=True)
            IDs = chunk[&#39;CID&#39;].unique().tolist()

            start_time = timeit.default_timer()
            with ThreadPoolExecutor(max_workers=rate_limit) as executor:
                futures = {executor.submit(self._fetch_data, int(cid)): cid for cid in IDs}
                for future in as_completed(futures):
                    cid, cpd_cpd_data, cpd_gene_data = future.result()
                    self._write_data_to_csv(cpd_cpd_data, f&#39;Data/Relationships/Cpd_Cpd_CoOcuurence/CID_{cid}.csv&#39;)
                    self._write_data_to_csv(cpd_gene_data, f&#39;Data/Relationships/Cpd_gene_CoOcuurence/CID_{cid}.csv&#39;,
                                            filter_condition={&#34;ID_2&#34;: [&#34;{&#39;GeneSymbol&#39;: &#39;cyp3a4&#39;}&#34;, &#34;{&#39;GeneSymbol&#39;: &#39;cyp1a2&#39;}&#34;,
                                                                    &#34;{&#39;GeneSymbol&#39;: &#39;cyp2c9&#39;}&#34;, &#34;{&#39;GeneSymbol&#39;: &#39;cyp2c19&#39;}&#34;,
                                                                    &#34;{&#39;GeneSymbol&#39;: &#39;cyp2d6&#39;}&#34;]})
                    time.sleep(1 / rate_limit)  # Ensuring we don&#39;t exceed rate limit
            elapsed = timeit.default_timer() - start_time
            logging.info(f&#34;Processed chunk in {elapsed:.2f} seconds&#34;)

        return &#34;Data fetching and saving completed.&#34;


    def compound_transformation(self, gene_properties):
        &#34;&#34;&#34;
        Analyzes compound transformation data based on gene properties, focusing on metabolic transformations
        involving specified genes. This method queries the PubChem database for transformation data related
        to compounds associated with the genes identified in the provided CSV file.

        Parameters:
            gene_properties (str): Path to the CSV file containing gene properties generated by the NodePropertiesExtractor
                                class, which should include &#39;GeneID&#39; as one of its columns. This file is used to identify
                                genes of interest for which compound transformation data will be fetched.

        Processing Steps:
            1. Reads the provided CSV file to extract unique gene identifiers.
            2. For each gene identifier, constructs a query to fetch relevant compound transformation data from
            PubChem, focusing on metabolic transformations where the gene plays a role.
            3. Processes and aggregates the fetched data into a structured pandas DataFrame.
            4. Filters the aggregated data to retain specific columns relevant to compound transformations,
            including substrate and metabolite Compound IDs (CIDs), the type of metabolic conversion, gene
            identifiers, PubMed IDs, and DOIs for related publications.
            5. Saves the aggregated and filtered DataFrame to a CSV file for further analysis or integration
            into knowledge graphs or other data models.

        Returns:
            pandas.DataFrame: A DataFrame containing processed compound transformation data, including substrate
                            and metabolite CIDs, metabolic conversion types, gene identifiers, PubMed IDs, and
                            DOIs. The DataFrame structure facilitates further analysis or use in constructing
                            detailed views of metabolic pathways involving the specified genes.

        Side Effects:
            - Saves the aggregated compound transformation data to &#39;Data/Relationships/Compound_Transformation.csv&#39;
            in the current working directory. This file captures the relationship between substrates, metabolites,
            and genes based on the input gene properties.

        Raises:
            FileNotFoundError: If the specified &#39;gene_properties&#39; file does not exist or cannot be read.
            ValueError: If &#39;gene_properties&#39; does not contain the required &#39;GeneID&#39; column.

        Example:
            &gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
            &gt;&gt;&gt; transformation_df = extractor.compound_transformation(&#39;Data/Nodes/gene_properties.csv&#39;)
            &gt;&gt;&gt; print(transformation_df.head())
            This example processes gene properties from &#39;path/to/gene_properties.csv&#39;, queries PubChem for
            compound transformation data related to the genes, and compiles the results into a DataFrame.

        Note:
            The method assumes that the input &#39;gene_properties&#39; file is accessible and correctly formatted.
            The availability and structure of the PubChem database may affect the completeness and accuracy
            of the fetched transformation data. Users should verify the existence of the &#39;Data/Relationships&#39;
            directory and have appropriate permissions to write files to it.
        &#34;&#34;&#34;
        df = pd.read_csv(gene_properties)
        IDs = df[&#39;GeneID&#39;].unique().tolist()

        transformation_dfs = []

        for gid in IDs:
            gid = int(gid)
            url = (f&#34;https://pubchem.ncbi.nlm.nih.gov/sdq/sdqagent.cgi?infmt=json&amp;outfmt=csv&#34;
                   f&#34;&amp;query={{\&#34;download\&#34;:\&#34;*\&#34;,\&#34;collection\&#34;:\&#34;chemblmetabolism\&#34;,\&#34;where\&#34;:&#34;
                   f&#34;{{\&#34;ands\&#34;:[{{\&#34;geneid\&#34;:\&#34;{gid}\&#34;}}]}},\&#34;order\&#34;:[\&#34;relevancescore,desc\&#34;]&#34;
                   f&#34;,\&#34;start\&#34;:1,\&#34;limit\&#34;:10000000,\&#34;downloadfilename\&#34;:\&#34;pubchem_geneid_{gid}_chemblmetabolism\&#34;}}&#34;)

            response = self._send_request(url)
            if response:
                try:
                    transformation_df = pd.read_csv(StringIO(response.text), sep=&#39;,&#39;, header=0, low_memory=False)
                    transformation_df = transformation_df[[&#39;substratecid&#39;, &#39;metabolitecid&#39;, &#39;metconversion&#39;, &#39;geneids&#39;, &#39;pmids&#39;, &#39;dois&#39;]]
                    transformation_dfs.append(transformation_df)
                except pd.errors.ParserError as e:
                    print(f&#34;Error parsing CSV for gene ID {gid}: {e}&#34;)
                    continue  # Skip this gene ID and continue with others

        transformation_df = pd.concat(transformation_dfs, ignore_index=True) if transformation_dfs else pd.DataFrame()
        self._write_to_csv(transformation_df, &#39;Data/Relationships/Compound_Transformation.csv&#39;)

        return transformation_df</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.assay_compound_relationship"><code class="name flex">
<span>def <span class="ident">assay_compound_relationship</span></span>(<span>self, assays_data, chunk_size=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes and stores relationships between assays and compounds based on assay data from PubChem.</p>
<p>The method utilizes chunk processing and limited concurrent requests to minimize memory usage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assays_data</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to a CSV file containing assay IDs (AIDs).</dd>
<dt><strong><code>chunk_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of rows per chunk to process from the assays_data file.</dd>
<dt><strong><code>max_workers</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of concurrent threads for data fetching.</dd>
</dl></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.assay_enzyme_relationship"><code class="name flex">
<span>def <span class="ident">assay_enzyme_relationship</span></span>(<span>self, main_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts and saves relationships between assays and enzymes from the specified dataset.</p>
<p>This method processes assay data to identify relationships between assays and their target enzymes. It selects
relevant columns from the input data, removes duplicates to ensure unique relationships, and saves the cleaned data
to a CSV file for further analysis or integration into knowledge graphs.</p>
<h2 id="parameters">Parameters</h2>
<p>main_data (str): Path to the CSV file containing the main data. The file should include columns for 'AID'
(Assay ID), 'Target GeneID', and 'Activity Name'.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A DataFrame containing the unique relationships between assays and enzymes, including the assay
ID, target gene ID, and activity name.</dd>
</dl>
<p>Side Effects:
- Writes a CSV file to 'Data/Assay_Enzyme_Relationship.csv', containing the processed relationships data.</p></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_cooccurrence"><code class="name flex">
<span>def <span class="ident">compound_cooccurrence</span></span>(<span>self, main_data, rate_limit=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyzes compound co-occurrence relationships from the specified main data file and saves the results into structured CSV files.</p>
<p>This method takes a path to a CSV file containing compound data and performs batch processing to extract relationships
between compounds and genes from the PubChem database. It filters compounds based on their association with specific genes
of interest, then fetches co-occurrence data for each compound using parallel requests. The data fetched includes both
compound-compound and compound-gene co-occurrence relationships. Results are saved in separate CSV files within specific
directories for later analysis.</p>
<h2 id="parameters">Parameters</h2>
<p>main_data (str): Path to the CSV file containing the main data. This file should include 'CID' (Compound ID) and
'Target GeneID' columns.
rate_limit (int): Controls the rate of API requests to avoid exceeding PubChem's request limits. Specifies the maximum
number of requests that can be made per second.</p>
<p>Side Effects:
- Creates CSV files in 'Data/Relationships/Cpd_Cpd_CoOcuurence' and 'Data/Relationships/Cpd_gene_CoOcuurence'
directories, storing compound-compound and compound-gene co-occurrence data, respectively.
- Logs the processing time for each chunk of data and any errors encountered during data fetching.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A message indicating the successful completion of data processing and saving.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified 'main_data' file does not exist or cannot be read.</dd>
<dt><code>ValueError</code></dt>
<dd>If 'main_data' does not contain the required columns ('CID' and 'Target GeneID').</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
&gt;&gt;&gt; completion_message = extractor.compound_cooccurrence('Data/AllDataConnected.csv', rate_limit=5)
&gt;&gt;&gt; print(completion_message)
This would process the compound data, fetch co-occurrence data from PubChem, and save the results into CSV files.
The completion message would indicate successful processing.
</code></pre>
<h2 id="note">Note</h2>
<p>The 'main_data' file must be properly formatted, with at least 'CID' and 'Target GeneID' columns present. The method
assumes the existence of 'Data/Relationships/Cpd_Cpd_CoOcuurence' and 'Data/Relationships/Cpd_gene_CoOcuurence'
directories for saving the output CSV files. It is recommended to check and adhere to PubChem's current rate limits
when setting the 'rate_limit' parameter to avoid potential blocks or restrictions on your IP address due to excessive requests.</p></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_enzyme_relationship"><code class="name flex">
<span>def <span class="ident">compound_enzyme_relationship</span></span>(<span>self, main_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Identifies and records relationships between compounds and enzymes from the input data.</p>
<p>This method focuses on extracting compound-enzyme interaction data, including activity outcomes and values. It selects
pertinent columns, removes duplicate records, and sorts the data by Compound ID and Target Accession for clarity. The
cleaned dataset is then saved to a CSV file, providing a structured view of how compounds interact with various enzymes,
which can be critical for drug discovery and pharmacological research.</p>
<h2 id="parameters">Parameters</h2>
<p>main_data (str): Path to the CSV file with compound and enzyme data. This file should contain columns for 'CID'
(Compound ID), 'Target Accession', 'Activity Outcome', 'Activity Name', and 'Activity Value [uM]'.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A DataFrame with processed compound-enzyme relationships, sorted and cleaned for direct analysis or database insertion.</dd>
</dl>
<p>Side Effects:
- Saves the processed relationships data to 'Data/Relationships/Compound_Enzyme_Relationship.csv', facilitating easy access and integration.</p></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_similarity_relationship"><code class="name flex">
<span>def <span class="ident">compound_similarity_relationship</span></span>(<span>self, main_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Identifies and records the similarity relationships between compounds based on a list of CIDs.</p>
<p>This method reads a CSV file containing compound data, filters compounds based on specific 'Target GeneID' values,
and fetches similar CIDs for each compound. The compounds are processed in chunks to manage memory usage and improve
efficiency. The results are saved into separate CSV files for each chunk.</p>
<h2 id="parameters">Parameters</h2>
<p>main_data (str): Path to the CSV file containing the main compound data. This file should include at least 'CID'
and 'Target GeneID' columns.</p>
<p>Side Effects:
- Reads from a CSV file specified by <code>main_data</code>.
- Processes compounds in chunks to efficiently handle large datasets.
- Saves the results of similar CIDs for each chunk to separate CSV files within 'Data/Relationships/Compound_Similarities' directory.
- Logs information about processing and potential errors during the similarity fetching process.</p>
<h2 id="note">Note</h2>
<ul>
<li>The method filters the main data for compounds associated with specific 'Target GeneID' values before fetching
similar CIDs, optimizing the process for relevant compounds only.</li>
<li>The division of CIDs into chunks and concurrent processing helps in managing large datasets and utilizes
parallelism for faster execution.</li>
</ul></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_transformation"><code class="name flex">
<span>def <span class="ident">compound_transformation</span></span>(<span>self, gene_properties)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyzes compound transformation data based on gene properties, focusing on metabolic transformations
involving specified genes. This method queries the PubChem database for transformation data related
to compounds associated with the genes identified in the provided CSV file.</p>
<h2 id="parameters">Parameters</h2>
<p>gene_properties (str): Path to the CSV file containing gene properties generated by the NodePropertiesExtractor
class, which should include 'GeneID' as one of its columns. This file is used to identify
genes of interest for which compound transformation data will be fetched.</p>
<p>Processing Steps:
1. Reads the provided CSV file to extract unique gene identifiers.
2. For each gene identifier, constructs a query to fetch relevant compound transformation data from
PubChem, focusing on metabolic transformations where the gene plays a role.
3. Processes and aggregates the fetched data into a structured pandas DataFrame.
4. Filters the aggregated data to retain specific columns relevant to compound transformations,
including substrate and metabolite Compound IDs (CIDs), the type of metabolic conversion, gene
identifiers, PubMed IDs, and DOIs for related publications.
5. Saves the aggregated and filtered DataFrame to a CSV file for further analysis or integration
into knowledge graphs or other data models.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A DataFrame containing processed compound transformation data, including substrate
and metabolite CIDs, metabolic conversion types, gene identifiers, PubMed IDs, and
DOIs. The DataFrame structure facilitates further analysis or use in constructing
detailed views of metabolic pathways involving the specified genes.</dd>
</dl>
<p>Side Effects:
- Saves the aggregated compound transformation data to 'Data/Relationships/Compound_Transformation.csv'
in the current working directory. This file captures the relationship between substrates, metabolites,
and genes based on the input gene properties.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified 'gene_properties' file does not exist or cannot be read.</dd>
<dt><code>ValueError</code></dt>
<dd>If 'gene_properties' does not contain the required 'GeneID' column.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
&gt;&gt;&gt; transformation_df = extractor.compound_transformation('Data/Nodes/gene_properties.csv')
&gt;&gt;&gt; print(transformation_df.head())
This example processes gene properties from 'path/to/gene_properties.csv', queries PubChem for
compound transformation data related to the genes, and compiles the results into a DataFrame.
</code></pre>
<h2 id="note">Note</h2>
<p>The method assumes that the input 'gene_properties' file is accessible and correctly formatted.
The availability and structure of the PubChem database may affect the completeness and accuracy
of the fetched transformation data. Users should verify the existence of the 'Data/Relationships'
directory and have appropriate permissions to write files to it.</p></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.create_data_directories"><code class="name flex">
<span>def <span class="ident">create_data_directories</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the necessary directories for storing fetched and processed data if they do not already exist.</p>
<p>This method checks for the existence of several predefined directories where data will be saved during the execution
of other methods within this class. If any of these directories do not exist, they are created. This setup ensures
that data saving operations do not encounter errors due to missing directories.</p>
<p>The directories created include:
- 'Data/Relationships/Assay_Compound_Relationship': For storing relationships between assays and compounds.
- 'Data/Relationships/Cpd_Cpd_CoOcuurence': For storing compound-compound co-occurrence data.
- 'Data/Relationships/Cpd_gene_CoOcuurence': For storing compound-gene co-occurrence data.
- 'Data/Relationships/Compound_Transformation': For storing compound transformation data.</p>
<p>Side Effects:
Creates directories on the filesystem if they do not exist.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
&gt;&gt;&gt; extractor.create_data_directories()
This example ensures that the required directories for data storage are available before fetching and processing data.
</code></pre>
<h2 id="note">Note</h2>
<p>This method should be called before executing data fetching and processing methods to ensure the required directories are available.
It is designed to prevent FileNotFoundError when methods attempt to save data to these directories.</p></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.fetch_data_for_aid"><code class="name flex">
<span>def <span class="ident">fetch_data_for_aid</span></span>(<span>self, aid, columns_to_remove)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches and processes assay data for a specified Assay ID (AID) from the PubChem database, preparing it for analysis or further processing.</p>
<p>This method queries the PubChem database for assay data associated with a given AID. It constructs the query URL,
sends the request using a previously established session, and processes the response. The response is expected to be in CSV format,
which this method reads into a pandas DataFrame. Specific columns can be removed from this DataFrame based on the requirements
for analysis. This allows for the customization of the fetched data, making it easier to work with specific datasets.</p>
<p>If the request is successful and the data is fetched without issues, it undergoes initial processing to remove unwanted columns
as specified by the 'columns_to_remove' parameter. In case of an error during the data fetching or processing (e.g., issues with parsing the CSV data),
appropriate error messages are logged, and an empty DataFrame is returned as a fallback.</p>
<h2 id="parameters">Parameters</h2>
<p>aid (int): The assay ID for which data is to be fetched. This ID is used to construct the query URL to the PubChem database.
columns_to_remove (list of str): A list of column names that should be removed from the fetched DataFrame. This allows for the exclusion
of data that might not be relevant to the subsequent analysis or processing steps.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A DataFrame containing the processed data associated with the given AID. The DataFrame will exclude columns listed
in 'columns_to_remove'. If the data fetching fails or if an error occurs during processing, an empty DataFrame is returned.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>requests.RequestException</code></dt>
<dd>If an error occurs during the HTTP request to the PubChem API. This includes scenarios such as timeout issues,
non-200 status codes, or network-related errors. The exception is handled internally with logging, but it's
important to be aware of its possibility.</dd>
<dt><code>pd.errors.ParserError</code></dt>
<dd>If an error occurs while parsing the CSV response from PubChem into a DataFrame. This could happen due to malformed
data or unexpected changes in the response format. Like with RequestException, this error is logged and results in
the return of an empty DataFrame.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; extractor = RelationshipPropertiesExtractor()
&gt;&gt;&gt; processed_data_df = extractor.fetch_data_for_aid(12345, ['UnwantedColumn1', 'UnwantedColumn2'])
&gt;&gt;&gt; print(processed_data_df.head())
This example demonstrates how to fetch and process assay data for the assay with ID 12345, removing 'UnwantedColumn1' and 'UnwantedColumn2'
from the resulting DataFrame. The first few rows of the processed DataFrame are printed as an output.
</code></pre>
<h2 id="note">Note</h2>
<ul>
<li>This method is part of a class that requires a valid session with the PubChem API. Ensure that the class is properly initialized and that
the session is active.</li>
<li>The removal of columns is an optional step and can be customized based on the analysis needs. If no columns need to be removed, pass an
empty list as 'columns_to_remove'.</li>
</ul></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.fetch_similar_cids"><code class="name flex">
<span>def <span class="ident">fetch_similar_cids</span></span>(<span>self, cid)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches similar compound IDs (CIDs) from the PubChem database for a given compound ID (CID) using 2D similarity.</p>
<p>This method queries the PubChem database to find compounds that are similar to the given CID based on 2D structural
similarity. The similarity threshold is set to 95%, and a maximum of 100 similar CIDs are fetched. The response is
parsed from XML format to extract the similar CIDs.</p>
<h2 id="parameters">Parameters</h2>
<p>cid (int): The compound ID for which similar CIDs are to be fetched.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing the original CID and a list of similar CIDs. If an error occurs, the list of similar</dd>
</dl>
<p>CIDs will be empty.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Logs an error message with the original CID and the exception if the request to PubChem fails or</dd>
</dl>
<p>if parsing the XML response encounters an error.</p>
<h2 id="note">Note</h2>
<ul>
<li>The method utilizes the <code>requests</code> library for HTTP requests and <code>xml.etree.ElementTree</code> for XML parsing.</li>
<li>In case of a request failure or parsing error, the method logs the error and returns the original CID with an
empty list, allowing the calling function to handle the exception as needed.</li>
</ul></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.gene_enzyme_relationship"><code class="name flex">
<span>def <span class="ident">gene_enzyme_relationship</span></span>(<span>self, main_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts and saves relationships between genes and enzymes based on the provided dataset.</p>
<p>This method selects relevant columns to highlight the relationships between genes and their corresponding enzymes.
It removes duplicate entries to ensure that each relationship is represented uniquely and saves the resultant data to
a CSV file. This facilitates easy integration of genetic data into knowledge bases or further analysis.</p>
<h2 id="parameters">Parameters</h2>
<p>main_data (str): Path to the CSV file containing gene and enzyme data. Expected columns include 'Target GeneID'
and 'Target Accession'.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A DataFrame of unique gene-enzyme relationships, including gene ID and enzyme accession numbers.</dd>
</dl>
<p>Side Effects:
- Writes the processed data to 'Data/Gene_Enzyme_Relationship.csv' in a structured CSV format.</p></div>
</dd>
<dt id="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.process_chunk"><code class="name flex">
<span>def <span class="ident">process_chunk</span></span>(<span>self, chunk)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes a chunk of CIDs in parallel to fetch similar CIDs for each CID in the chunk.</p>
<p>This method uses a ThreadPoolExecutor to send out concurrent requests for fetching similar CIDs for a list of CIDs.
The number of worker threads is set to 5. Each CID's request is handled by <code>fetch_similar_cids</code> method.</p>
<h2 id="parameters">Parameters</h2>
<p>chunk (list of int): A list of compound IDs (CIDs) to process in parallel.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>tuples</code></dt>
<dd>A list of tuples, each containing a CID and its corresponding list of similar CIDs.</dd>
</dl>
<p>Side Effects:
- Utilizes concurrent threads to speed up the fetching process.
- May log errors if any occur during the fetching of similar CIDs for individual CIDs.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="chemgraphbuilder" href="index.html">chemgraphbuilder</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor">RelationshipPropertiesExtractor</a></code></h4>
<ul class="">
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.assay_compound_relationship" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.assay_compound_relationship">assay_compound_relationship</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.assay_enzyme_relationship" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.assay_enzyme_relationship">assay_enzyme_relationship</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_cooccurrence" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_cooccurrence">compound_cooccurrence</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_enzyme_relationship" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_enzyme_relationship">compound_enzyme_relationship</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_similarity_relationship" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_similarity_relationship">compound_similarity_relationship</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_transformation" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.compound_transformation">compound_transformation</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.create_data_directories" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.create_data_directories">create_data_directories</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.fetch_data_for_aid" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.fetch_data_for_aid">fetch_data_for_aid</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.fetch_similar_cids" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.fetch_similar_cids">fetch_similar_cids</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.gene_enzyme_relationship" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.gene_enzyme_relationship">gene_enzyme_relationship</a></code></li>
<li><code><a title="chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.process_chunk" href="#chemgraphbuilder.relationship_properties_extractor.RelationshipPropertiesExtractor.process_chunk">process_chunk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
